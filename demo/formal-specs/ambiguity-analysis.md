# 形式手法による曖昧性分析レポート

## 概要
自然言語要件をAlloyとTLA+で形式化することにより、以下の重大な曖昧性と問題点が発見されました。

## 発見された主要な曖昧性

### 1. 在庫管理の曖昧性

#### 🚨 問題1: 在庫チェックのタイミング
**自然言語要件**: "在庫がある本のみ注文可能"

**発見された曖昧性**:
- 在庫チェックは注文作成時？確定時？
- 複数の同時注文に対してどう対応するか？

**Alloyで発見されたシナリオ**:
```alloy
// 在庫1冊に対して2件の同時注文が可能
run RaceConditionScenario {
    some disj o1, o2: Order |
        o1.status = Pending and o2.status = Pending and
        some oi1: o1.items, oi2: o2.items | 
            oi1.book = oi2.book and
            (oi1.quantity + oi2.quantity) > physicalStock
}
```

**TLA+で発見された競合状態**:
```tla
PlaceOrder(customer, book, quantity) ==
    \* 問題: 在庫チェックなしで注文を受け付ける
    /\ orders' = Append(orders, [customer |-> customer, book |-> book, quantity |-> quantity])
    /\ UNCHANGED inventory  \* 在庫は変更されない
```

#### 🚨 問題2: 在庫引き当てのタイミング
**自然言語要件**: "注文後、在庫から商品を引き当てる"

**発見された曖昧性**:
- "注文後"とは注文作成直後？確定後？
- 引き当てと実際の在庫減少のタイミングは？

**TLA+で発見された問題**:
```tla
ConfirmOrder(orderIndex) ==
    \* 問題: チェックと更新が原子的でない
    /\ inventory[order.book].physicalStock >= order.quantity  \* チェック
    /\ inventory' = [inventory EXCEPT ...]                    \* 更新
    \* 他のプロセスがこの間に割り込み可能
```

### 2. 並行処理の曖昧性

#### 🚨 問題3: 同時注文の処理順序
**自然言語要件**: "同じ本を複数の顧客が同時に注文することがある"

**発見された曖昧性**:
- 同時注文の優先順位は？
- 先着順？顧客ランク順？
- 部分的な在庫割り当ては可能？

**TLA+で発見された競合**:
```tla
\* 2つの注文が同時に確定処理される可能性
ConfirmOrder(1) || ConfirmOrder(2)
\* 両方とも在庫チェックを通過してしまう
```

#### 🚨 問題4: 排他制御の欠如
**発見された問題**:
- 同一商品への同時アクセス制御なし
- 在庫更新の原子性が保証されていない

### 3. 状態遷移の曖昧性

#### 🚨 問題5: キャンセル可能な状態の範囲
**自然言語要件**: "注文確定後はキャンセル可能"

**発見された曖昧性**:
- 発送後もキャンセル可能？
- 支払い完了後のキャンセルは？
- 部分発送時のキャンセルは？

**Alloyで発見された不整合**:
```alloy
fact CancellationConstraint {
    all o: Order | {
        o.status = Cancelled implies {
            // 前の状態が不明確
            o.status.prev in (Pending + Confirmed + Shipped) // 無効な構文
        }
    }
}
```

#### 🚨 問題6: 支払いと確定の関係
**発見された曖昧性**:
- 支払い完了前に注文確定可能？
- 支払い失敗時の確定済み注文の扱いは？

**TLA+で発見されたシナリオ**:
```tla
\* 支払い失敗後の確定済み注文
PaymentFailureAfterConfirmation ==
    /\ orderStatus[i] = "confirmed"
    /\ payments[i] = "failed"
    \* この状態をどう処理する？
```

### 4. 在庫復元の曖昧性

#### 🚨 問題7: 在庫復元のタイミングと影響
**自然言語要件**: "キャンセル時は在庫を復元する"

**発見された曖昧性**:
- 復元は即座に？バッチ処理？
- 他の待機注文への自動割り当ては？
- 復元処理の失敗時の対応は？

**Alloyで発見された不完全な制約**:
```alloy
fact StockRestorationOnCancellation {
    all o: Order | {
        o.status = Cancelled implies {
            // 復元メカニズムが不明確
            some inv: Inventory | inv.book = oi.book
            // 他の注文への影響が未定義
        }
    }
}
```

## 検証で失敗する安全性プロパティ

### Alloyアサーション違反

1. **NoOverbooking**: 総注文数が在庫を超える
2. **InventoryConsistency**: 予約数が物理在庫を超える
3. **PaymentOrderConsistency**: 支払い未完了の確定注文

### TLA+プロパティ違反

1. **InventoryNeverNegative**: 在庫がマイナスになる
2. **ReservedStockConsistency**: 予約在庫の不整合
3. **ConfirmedOrdersHavePayments**: 支払い未完了の確定注文

## 発見された典型的な問題パターン

### パターン1: Check-Then-Act競合
```
状態1: 在庫チェック(OK) | 在庫チェック(OK)
状態2: 在庫更新      | 在庫更新
結果: 在庫がマイナス
```

### パターン2: 状態遷移の不整合
```
注文状態: Pending → Confirmed → Shipped
支払状態: Pending → Failed
結果: 支払い失敗だが商品は発送済み
```

### パターン3: 復元処理の競合
```
注文A: キャンセル → 在庫復元
注文B: 同時に確定処理
結果: 復元前の在庫で確定処理が実行
```

## 明確化が必要な仕様項目

### 高優先度（システムの整合性に直結）

1. **在庫管理の原子性**
   - 在庫チェック・予約・更新を単一トランザクションで実行
   - 同一商品への同時アクセス制御

2. **状態遷移ルールの明確化**
   - 各状態から遷移可能な状態の定義
   - 遷移条件の明確化（支払い完了、在庫確保等）

3. **並行処理制御**
   - 同時注文の処理順序（FIFO、優先度等）
   - デッドロック回避メカニズム

### 中優先度（ビジネスロジックの明確化）

4. **キャンセルポリシー**
   - キャンセル可能な状態の範囲
   - キャンセル時の在庫復元ルール
   - 部分キャンセルの可否

5. **支払い処理との連携**
   - 支払いタイミング（注文時、確定時、発送時）
   - 支払い失敗時の処理フロー

### 低優先度（運用・パフォーマンス）

6. **エラーハンドリング**
   - システム障害時の状態復旧
   - 部分的な処理失敗の対応

7. **パフォーマンス制約**
   - 同時処理数の上限
   - タイムアウト処理

## 次のステップ

1. **制約の明確化**: 発見された曖昧性に対する明確なビジネスルールの定義
2. **改良された形式仕様**: 明確化されたルールに基づく形式仕様の再作成
3. **型安全な実装**: 代数的データ型を用いた制約の実装レベルでの表現
4. **プロパティベーステスト**: 明確化された制約の継続的検証

## 結論

形式手法により、自然言語要件では見落とされがちな以下の重要な問題が明らかになりました：

- **並行性の問題**: 同時アクセスによる競合状態
- **状態管理の問題**: 不整合な状態遷移の可能性
- **ビジネスロジックの曖昧性**: 例外ケースの処理が未定義

これらの問題を事前に発見することで、実装段階での手戻りを大幅に削減し、より堅牢なシステムの構築が可能になります。 