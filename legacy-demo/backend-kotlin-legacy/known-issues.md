# Legacy Backend Implementation - Known Issues

この実装は従来の開発手法による問題のあるパターンを実演するためのものです。以下の問題が意図的に含まれています：

## アーキテクチャ設計の問題

### 1. レイヤー間の責務混在
- **問題**: ビジネスロジックがEntity、Service、Controllerに分散
- **影響**: 保守性の低下、テストの困難さ
- **例**: `ExpenseEntity.getRequiredApprovers()` (ExpenseEntity.kt:32)

### 2. データモデルの問題
- **問題**: Mutableなエンティティ、型安全性の欠如
- **影響**: 予期しない状態変更、ランタイムエラー
- **例**: `var status: String` (ExpenseEntity.kt:18)

### 3. ドメインロジックの散在
- **問題**: 承認ロジックが複数箇所に重複
- **影響**: 仕様変更時の修正漏れ
- **例**: `canApprove` メソッドの重複実装

## データ整合性の問題

### 1. 型安全性の欠如
- **ファイル**: 全ファイル
- **問題**: String型でのenum表現、Double型での金額表現
- **例**: `var role: String` (UserEntity.kt:45)
- **リスク**: 無効な値の混入、計算精度の問題

### 2. データ検証の不足
- **ファイル**: `ExpenseService.kt`, `ExpenseController.kt`
- **問題**: 入力値の検証が不十分
- **例**: 負の金額、空の申請者名を許可
- **リスク**: 無効なデータの永続化

### 3. 参照整合性の未保証
- **ファイル**: `ExpenseEntity.kt`
- **問題**: 外部キー制約の欠如
- **例**: `var managerId: Long?` (UserEntity.kt:46)
- **リスク**: 存在しないユーザーへの参照

## 状態管理の問題

### 1. ミューテブルな状態
- **ファイル**: 全エンティティ
- **問題**: オブジェクトの状態が予期せず変更される
- **例**: `expense.submit()` での直接的な状態変更
- **リスク**: 並行処理での競合状態

### 2. 文字列によるデータ保存
- **ファイル**: `ExpenseEntity.kt`
- **問題**: 承認履歴をCSV形式で保存
- **例**: `var approvals: String` (ExpenseEntity.kt:21)
- **リスク**: パース エラー、データ破損

### 3. キャッシュの不整合
- **ファイル**: `ExpenseService.kt`
- **問題**: 手動キャッシュ管理でデータ不整合
- **例**: `cachedUsers` の更新タイミング問題
- **リスク**: 古いデータに基づく処理

## ビジネスロジックの問題

### 1. 承認権限チェックの不備
- **ファイル**: `ExpenseService.kt`
- **問題**: 自己承認防止が不完全
- **例**: `canApprove` メソッドの条件不足
- **リスク**: 不正な承認の可能性

### 2. 状態遷移の不整合
- **ファイル**: `ExpenseService.kt`
- **問題**: 承認順序の強制が不十分
- **例**: Director が Manager 承認前に承認可能
- **リスク**: ビジネスルール違反

### 3. エラーハンドリングの不備
- **ファイル**: 全ファイル
- **問題**: 例外処理が適切でない
- **例**: Silent failure、Generic error messages
- **リスク**: 問題の早期発見ができない

## パフォーマンスの問題

### 1. N+1 クエリ問題
- **ファイル**: `ExpenseService.kt`
- **問題**: ループ内でのDB アクセス
- **例**: `getUserByEmail` の繰り返し呼び出し
- **リスク**: パフォーマンス劣化

### 2. 全件取得による処理
- **ファイル**: `ExpenseController.kt`
- **問題**: ページネーションなしの全件取得
- **例**: `getAllExpenses()` (ExpenseController.kt:67)
- **リスク**: メモリ不足、レスポンス遅延

### 3. 非効率なフィルタリング
- **ファイル**: `ExpenseService.kt`
- **問題**: アプリケーション層でのフィルタリング
- **例**: `getExpensesForApproval` でのfilter処理
- **リスク**: 不要なデータ転送

## セキュリティの問題

### 1. 認証・認可の不備
- **ファイル**: `ExpenseController.kt`
- **問題**: エンドポイントに認証チェックなし
- **リスク**: 不正アクセスの可能性

### 2. 入力値検証の不足
- **ファイル**: `ExpenseController.kt`
- **問題**: リクエストパラメータの検証が不十分
- **例**: Type casting without validation
- **リスク**: インジェクション攻撃

### 3. エラー情報の漏洩
- **ファイル**: `ExpenseController.kt`
- **問題**: 内部エラーをそのまま返却
- **例**: `"Error: ${e.message}"` (ExpenseController.kt:29)
- **リスク**: システム情報の漏洩

## テスタビリティの問題

### 1. 密結合の設計
- **ファイル**: 全ファイル
- **問題**: 依存関係が複雑でモック化困難
- **リスク**: 単体テストの実装困難

### 2. 副作用の多い処理
- **ファイル**: `ExpenseService.kt`
- **問題**: メソッドに複数の副作用
- **例**: `approveExpense` で複数のDB更新
- **リスク**: テスト時の状態管理困難

### 3. ビジネスロジックの分散
- **ファイル**: 全ファイル
- **問題**: ロジックが複数箇所に分散
- **リスク**: 一貫性のあるテストの困難さ

## データベース設計の問題

### 1. 正規化の不備
- **ファイル**: `ExpenseEntity.kt`
- **問題**: 承認履歴が非正規化されて保存
- **リスク**: データ重複、更新異常

### 2. インデックスの欠如
- **ファイル**: Repository classes
- **問題**: 検索頻度の高いカラムにインデックスなし
- **リスク**: クエリパフォーマンス劣化

### 3. 制約の不足
- **ファイル**: Entity classes
- **問題**: DB レベルでの制約が不十分
- **リスク**: データ整合性の破綻

---

## 改善方針

これらの問題は Phase 2, 3 で以下の手法により解決されます：

### 1. 関数型プログラミング
- **Immutable data structures**: 状態の不変性保証
- **Pure functions**: 副作用の分離
- **Type safety**: sealed class, enum class の活用

### 2. ドメイン駆動設計
- **適切な境界**: ドメインオブジェクトの責務明確化
- **Aggregate pattern**: 整合性境界の設定
- **Repository pattern**: データアクセスの抽象化

### 3. 形式手法の活用
- **Design by Contract**: 事前条件・事後条件の明示
- **State machine**: 状態遷移の形式化
- **Property-based testing**: 不変条件の検証

### 4. 適切なアーキテクチャ
- **Layer separation**: 明確な責務分離
- **Dependency injection**: テスタビリティの向上
- **Error handling**: Either/Result パターンの活用